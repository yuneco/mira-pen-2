---
description: 基本的にコーディングルール。新規のコードを描くときはもちろん、リファクタリング時にも参照すること
globs: 
alwaysApply: false
---
- nullとundefinedは混在させない
  - 原則としてundefinedの使用を優先する
  - ただし、DOMのイベントハンドラと密接に連携する場所など、入力としてnullが使用される文脈ではnullを優先しても構わない

- exportする関数や変数にはJS Docでコメントを書く
  - @paramsや@returnは内容が自明であれば省略してもよい
  - 関数の説明は関数の内部処理ではなく、外部仕様に基づいて書くこと

# コード修正時の注意事項

## biomeの基本的なルールに従う
- 型のimportは`import type`を使う
- 特段の理由がなければ`forEach`ではなく`for of`を使う

## リファクタリングを行うときは、修正前後の挙動が等価であることを明示的に確認する

## 不要になった変数やimport定義は都度削除する

コードの変更に伴い不要になった変数やimport定義は、その都度削除する。特に以下の点に注意する：

- 型のimportが実際に型アノテーションとして使用されているか確認する
- 間接的に型が参照されている場合（例：useAtomから型が推論される場合）は、明示的なimportが不要な可能性がある
- リファクタリング後に不要になったファイルは完全に削除する。ただし、ファイルの誤削除を避けるため、削除を行う際は具体的に削除対象と理由を述べ、Acceptされた場合のみ実際の削除を行うこと
- 変数の使用箇所を確認し、未使用の変数は削除する

不要なコードを残すと、コードの可読性が低下し、将来的なバグの原因になる可能性がある。 

# TypeScript型安全性のベストプラクティス

## 1. 判別可能なユニオン型（Discriminated Unions）の活用

状態や種類が異なるオブジェクトを表現する場合は、`type`フィールドを持つ判別可能なユニオン型を使用する。これにより型の安全性が向上し、型ガードが簡潔になる。

## 2. 配列の長さを型で保証する

特定の長さの配列を扱う場合は、タプル型を使用して要素数を型レベルで保証する。

## 3. イミュータビリティの活用

データの不変性を保証するために`readonly`修飾子を積極的に使用する。これにより意図しない変更を防止できる。

## 4. 非null断言演算子（!）の使用を避ける

非null断言演算子（`!`）の使用は避け、代わりに適切な条件チェックを行う。

## 5. 型の網羅性チェックを活用する

ユニオン型を使用する際は、すべてのケースを網羅するようにし、TypeScriptの網羅性チェックを活用する。

## 6. 純粋関数はコンポーネント外に定義する

コンポーネントの状態や props に依存しない純粋関数は、コンポーネント外に定義する。これにより再レンダリング時のパフォーマンスが向上し、テストも容易になる。 